<!DOCTYPE html>
<html>
    <head>
        <meta name="description" content="..." />
        <meta http-equiv="Content-Type" CONTENT="text/html; charset="utf-8" />
        <script type="text/javascript" src="../js/ga.js"></script>
        <title>Parse::Eyapp::translationschemestut - Introduction to Translation</title>
        <META NAME="robots" CONTENT="all" />
    </head>
    
<content><pre>

Parse::Eyapp::translatUsercContributed PParse::Eyapp::translationschemestut(3)



NAME
       Parse::Eyapp::translationschemestut - Introduction to Translation
       Schemes in Eyapp

INTRODUCTION
       A translation scheme scheme is a context free grammar where the right
       hand sides of the productions have been augmented with semantic actions
       (i.e. with chunks of Perl code):

				       A -&gt alpha { action(@_) } beta

       The analyzer generated by "Parse::Eyapp" executes "action()" after all
       the semantic actions associated with "alpha" have been executed and
       before the execution of any of the semantic actions associated with
       "beta".

       In a translation scheme the embedded actions modify the attributes
       associated with the symbols of the grammar.

				       A -&gt alpha { action(@_) } beta

       each symbol on the right hand side of a production rule has an
       associated scalar attribute. In ordinary "eyapp" programs the
       attributes of the symbol to the left of "action" are passed as
       arguments to "action" (in the example, those of "alpha").  These
       arguments are preceded by a reference to the syntax analyzer object.
       There is no way inside an ordinary "eyapp" program for an intermediate
       "action" to access the attributes of the symbols on its right, i.e.
       those associated with the symbols of "beta". This restriction is lifted
       if you  use the %metatree directive.

       Eyapp allows through the %metatree directive the creation of
       Translation Schemes where the actions have access to almost any node of
       the syntax tree.

       When using the %metatree directive semantic actions aren't immediately
       executed. Instead they are inserted as nodes of the syntax tree. The
       main difference with ordinary nodes being that the attribute of such a
       "CODE" node is a reference to the anonymous subroutine representing the
       semantic action.  The tree is later traversed in depth-first order
       using the "$t-&gttranslation_scheme" method: each time a "CODE" node is
       visited	the action is executed.

       The following example parses a tiny subset of a typical typed language
       and decorates the syntax tree with a new attribute "t" holding the type
       of each declared variable:

	use strict; # File examples/trans_scheme_simple_decls4.pl
	use Data::Dumper;
	use Parse::Eyapp;
	our %s; # symbol table

	my $ts = q{
	  %token FLOAT INTEGER NAME

	  %{
	  our %s;
	  %}

	  %metatree

	  %%
	  Dl:  D &lt* ';'&gt
	  ;

	  D : $T { $L-&gt{t} = $T-&gt{t} } $L
	  ;

	  T : FLOAT    { $lhs-&gt{t} = "FLOAT" }
	    | INTEGER  { $lhs-&gt{t} = "INTEGER" }
	  ;

	  L : $NAME
		{ $NAME-&gt{t} = $lhs-&gt{t}; $s{$NAME-&gt{attr}} = $NAME }
	    | $NAME { $NAME-&gt{t} = $lhs-&gt{t}; $L-&gt{t} = $lhs-&gt{t} } ',' $L
		{ $s{$NAME-&gt{attr}} = $NAME }
	  ;
	  %%
	}; # end $ts

	sub Error { die "Error sintA~Xctico\n"; }

	{ # Closure of $input, %reserved_words and $validchars
	  my $input = "";
	  my %reserved_words = ();
	  my $validchars = "";

	  sub parametrize__scanner {
	    $input = shift;
	    %reserved_words = %{shift()};
	    $validchars = shift;
	  }

	  sub scanner {
	    $input =~ m{\G\s+}gc;		      # skip whites
	    if ($input =~ m{\G([a-z_A_Z]\w*)\b}gc) {
	      my $w = uc($1);		      # upper case the word
	      return ($w, $w) if exists $reserved_words{$w};
	      return ('NAME', $1);	      # not a reserved word
	    }
	    return ($1, $1) if ($input =~ m/\G([$validchars])/gc);
	    die "Not valid token: $1\n" if ($input =~ m/\G(\S)/gc);
	    return ('', undef); # end of file
	  }
	} # end closure

	Parse::Eyapp-&gtnew_grammar(input=&gt$ts,classname=&gt'main',outputfile=&gt'Types.pm');
	my $parser = main-&gtnew(yylex =&gt \&scanner, yyerror =&gt \&Error);

	parametrize__scanner(
	  "float x,y;\ninteger a,b\n",
	  { INTEGER =&gt 'INTEGER', FLOAT =&gt 'FLOAT'},
	  ",;"
	);

	my $t = $parser-&gtYYParse() or die "Syntax Error analyzing input";

	$t-&gttranslation_scheme;

	$Data::Dumper::Indent = 1;
	$Data::Dumper::Terse = 1;
	$Data::Dumper::Deepcopy  = 1;
	$Data::Dumper::Deparse = 1;
	print Dumper($t);
	print Dumper(\%s);

       Inside a Translation Scheme the lexical variable $lhs refers to the
       attribute of the father.

EXECUTION STAGES OF A TRANSLATION SCHEME
       The execution of a Translation Scheme can be divided in the following
       stages:

       1. During the first stage the grammar is analyzed and the parser is
       built:
	    Parse::Eyapp-&gtnew_grammar(input=&gt$ts,classname=&gt'main',outputfile=&gt'Types.pm');

	   This stage is called Class Construction Time

       2. A parser conforming to the generated grammar is built
	     my $parser = main-&gtnew(yylex =&gt \&scanner, yyerror =&gt \&Error);

	   This stage is called  Parser Construction Time

       3. The next phase is Tree construction time. The input is set and the
       tree is built:
	    parametrize__scanner(
	       "float x,y;\ninteger a,b\n",
	       { INTEGER =&gt 'INTEGER', FLOAT =&gt 'FLOAT'},
	       ",;"
	     );

	     my $t = $parser-&gtYYParse() or die "Syntax Error analyzing input";

       4. The last stage is Execution Time. The tree is traversed in depth
       first order and the "CODE" nodes are executed.
				      $t-&gttranslation_scheme;

       This combination of bottom-up parsing with depth first traversing leads
       to a semantic behavior similar to recursive top-down parsers but with
       two advantages:

       o   The grammar can be left-recursive

       o   At the time of executing the action the syntax tree is already
	   built, therefore we can refer to nodes on the right side of the
	   action like in:

				 D : $T { $L-&gt{t} = $T-&gt{t} } $L

THE %begin DIRECTIVE
       The "%begin { code }" directive	can be used when building a
       translation scheme, i.e. when under the control of the %metatree
       directive.  It indicates that such "{ code }" will be executed at tree
       construction time. Therefore the code receives as arguments the
       references to the nodes of the branch than is being built.  Usually
       begin code assist in the construction of the tree.  Line 39 of the
       following code shows an example.  The action "{ $exp }" simplifies the
       syntax tree bypassing the parenthesis node. The example also
       illustrates the combined use of default actions and translation
       schemes.

	 pl@nereida:~/LEyapp/examples$ cat -n trans_scheme_default_action.pl
	    1  #!/usr/bin/perl -w
	    2  use strict;
	    3  use Data::Dumper;
	    4  use Parse::Eyapp;
	    5  use IO::Interactive qw(is_interactive);
	    6
	    7  my $translationscheme = q{
	    8  %{
	    9  # head code is available at tree construction time
	   10  use Data::Dumper;
	   11  our %sym; # symbol table
	   12  %}
	   13
	   14  %defaultaction {
	   15	  $lhs-&gt{n} = eval " $left-&gt{n} $_[2]-&gt{attr} $right-&gt{n} "
	   16  }
	   17
	   18  %metatree
	   19
	   20  %right	'='
	   21  %left   '-' '+'
	   22  %left   '*' '/'
	   23
	   24  %%
	   25  line:	   %name EXP
	   26		     exp &lt+ ';'&gt /* Expressions separated by semicolons */
	   27		       { $lhs-&gt{n} = $_[1]-&gtLast_child-&gt{n} }
	   28  ;
	   29
	   30  exp:
	   31		   %name PLUS
	   32		     exp.left '+' exp.right
	   33	       |   %name MINUS
	   34		     exp.left '-' exp.right
	   35	       |   %name TIMES
	   36		     exp.left '*' exp.right
	   37	       |   %name DIV
	   38		     exp.left '/' exp.right
	   39	       |   %name NUM
	   40		     $NUM
	   41		       { $lhs-&gt{n} = $NUM-&gt{attr} }
	   42	       |   '(' $exp ')'  %begin { $exp }
	   43	       |   %name VAR
	   44		     $VAR
	   45		       { $lhs-&gt{n} = $sym{$VAR-&gt{attr}}-&gt{n} }
	   46	       |   %name ASSIGN
	   47		     $VAR '=' $exp
	   48		       { $lhs-&gt{n} = $sym{$VAR-&gt{attr}}-&gt{n} = $exp-&gt{n} }
	   49
	   50  ;
	   51
	   52  %%
	   53  # tail code is available at tree construction time
	   54  sub _Error {
	   55	 die "Syntax error.\n";
	   56  }
	   57
	   58  sub _Lexer {
	   59	   my($parser)=shift;
	   60
	   61	   for ($parser-&gtYYData-&gt{INPUT}) {
	   62	       s/^\s+//;
	   63	       $_ or  return('',undef);
	   64	       s/^([0-9]+(?:\.[0-9]+)?)// and return('NUM',$1);
	   65	       s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
	   66	       s/^(.)// and return($1,$1);
	   67	   }
	   68	   return('',undef);
	   69  }
	   70
	   71  sub Run {
	   72	   my($self)=shift;
	   73	   return $self-&gtYYParse( yylex =&gt \&_Lexer, yyerror =&gt \&_Error );
	   74  }
	   75  }; # end translation scheme
	   76
	   77  sub TERMINAL::info { $_[0]-&gtattr }
	   78
	   79  my $p = Parse::Eyapp-&gtnew_grammar(
	   80	 input=&gt$translationscheme,
	   81	 classname=&gt'main',
	   82	 firstline =&gt 6,
	   83	 outputfile =&gt 'main.pm');
	   84  die $p-&gtqtables() if $p-&gtWarnings;
	   85  my $parser = main-&gtnew();
	   86  print "Write a sequence of arithmetic expressions: " if is_interactive();
	   87  $parser-&gtYYData-&gt{INPUT} = &lt&gt;
	   88  my $t = $parser-&gtRun() or die "Syntax Error analyzing input";
	   89  $t-&gttranslation_scheme;
	   90
	   91  $Parse::Eyapp::Node::INDENT = 2;
	   92  my $treestring = $t-&gtstr;
	   93
	   94  $Data::Dumper::Indent = 1;
	   95  $Data::Dumper::Terse = 1;
	   96  $Data::Dumper::Deepcopy	= 1;
	   97  our %sym;
	   98  my $symboltable = Dumper(\%sym);
	   99
	  100  print &lt&lt"EOR";
	  101  ***********Tree*************
	  102  $treestring
	  103  ******Symbol table**********
	  104  $symboltable
	  105  ************Result**********
	  106  $t-&gt{n}
	  107
	  108  EOR

       When executed with input "a=2*3;b=a*a" the program produces an output
       similar to this:

	 pl@nereida:~/LEyapp/examples$ trans_scheme_default_action.pl
	 Write a sequence of arithmetic expressions: a=2*3;b=a*a
	 ***********Tree*************

	 EXP(
	   _PLUS_LIST(
	     ASSIGN(
	       TERMINAL[a],
	       TERMINAL[=],
	       TIMES(
		 NUM(TERMINAL[2], CODE),
		 TERMINAL[*],
		 NUM(TERMINAL[3], CODE),
		 CODE
	       ) # TIMES,
	       CODE
	     ) # ASSIGN,
	     ASSIGN(
	       TERMINAL[b],
	       TERMINAL[=],
	       TIMES(
		 VAR(TERMINAL[a], CODE),
		 TERMINAL[*],
		 VAR(TERMINAL[a], CODE),
		 CODE
	       ) # TIMES,
	       CODE
	     ) # ASSIGN
	   ) # _PLUS_LIST,
	   CODE
	 ) # EXP
	 ******Symbol table**********
	 {
	   'a' =&gt {
	     'n' =&gt 6
	   },
	   'b' =&gt {
	     'n' =&gt 36
	   }
	 }

	 ************Result**********
	 36

SEE ALSO
       o   The project home is at http://code.google.com/p/parse-eyapp/
	   &lthttp://code.google.com/p/parse-eyapp/&gt.  Use a subversion client
	   to anonymously check out the latest project source code:

	      svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only

       o   The tutorial Parsing Strings and Trees with "Parse::Eyapp" (An
	   Introduction to Compiler Construction in seven pages) in
	   &lthttp://nereida.deioc.ull.es/~pl/eyapsimple/&gt

       o   Parse::Eyapp, Parse::Eyapp::eyapplanguageref,
	   Parse::Eyapp::debuggingtut, Parse::Eyapp::defaultactionsintro,
	   Parse::Eyapp::translationschemestut, Parse::Eyapp::Driver,
	   Parse::Eyapp::Node, Parse::Eyapp::YATW, Parse::Eyapp::Treeregexp,
	   Parse::Eyapp::Scope, Parse::Eyapp::Base,
	   Parse::Eyapp::datagenerationtut

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt

       o   The pdf file in
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt

       o   perldoc eyapp,

       o   perldoc treereg,

       o   perldoc vgg,

       o   The Syntax Highlight file for vim at
	   &lthttp://www.vim.org/scripts/script.php?script_id=2453&gt and
	   &lthttp://nereida.deioc.ull.es/~vim/&gt

       o   Analisis Lexico y Sintactico, (Notes for a course in compiler
	   construction) by  Casiano Rodriguez-Leon.  Available at
	   &lthttp://nereida.deioc.ull.es/~pl/perlexamples/&gt Is the more
	   complete and reliable source for Parse::Eyapp. However is in
	   Spanish.

       o   Parse::Yapp,

       o   Man pages of yacc(1) and bison(1),
	   &lthttp://www.delorie.com/gnu/docs/bison/bison.html&gt

       o   Language::AttributeGrammar

       o   Parse::RecDescent.

       o   HOP::Parser

       o   HOP::Lexer

       o   ocamlyacc tutorial at
	   http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html
	   &lthttp://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-
	   tutorial/ocamlyacc-tutorial.html&gt

REFERENCES
       o   The classic Dragon's book Compilers: Principles, Techniques, and
	   Tools by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman (Addison-
	   Wesley 1986)

       o   CS2121: The Implementation and Power of Programming Languages (See
	   &lthttp://www.cs.man.ac.uk/~pjj&gt,
	   &lthttp://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt and
	   &lthttp://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt) by Pete Jinks

CONTRIBUTORS
       o Hal Finkel &lthttp://www.halssoftware.com/&gt

       o G. Williams &lthttp://kasei.us/&gt

       o Thomas L. Shinnick &lthttp://search.cpan.org/~tshinnic/&gt

       o Frank Leray

AUTHOR
       Casiano Rodriguez-Leon (casiano@ull.es)

ACKNOWLEDGMENTS
       This work has been supported by CEE (FEDER) and the Spanish Ministry of
       Educacion y Ciencia through Plan Nacional I+D+I number
       TIN2005-08818-C04-04 (ULL::OPLINK project &lthttp://www.oplink.ull.es/&gt).
       Support from Gobierno de Canarias was through GC02210601 (Grupos
       Consolidados).  The University of La Laguna has also supported my work
       in many ways and for many years.

       A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
       The author of Parse::Yapp is Francois Desarmenien.

       I wish to thank Francois Desarmenien for his Parse::Yapp module, to my
       students at La Laguna and to the Perl Community. Thanks to the people
       who have contributed to improve the module (see "CONTRIBUTORS" in
       Parse::Eyapp).  Thanks to Larry Wall for giving us Perl.  Special
       thanks to Juana.

LICENCE AND COPYRIGHT
       Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es). All
       rights reserved.

       Parse::Yapp copyright is of Francois Desarmenien, all rights reserved.
       1998-2001

       These modules are free software; you can redistribute it and/or modify
       it under the same terms as Perl itself. See perlartistic.

       This program is distributed in the hope that it will be useful, but
       WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



perl v5.12.4			  2011-0Parse::Eyapp::translationschemestut(3)
    </pre></body>

</html>
