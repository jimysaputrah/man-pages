<!DOCTYPE html>
<html>
    <head>
        <meta name="description" content="The random() function uses a non-linear, additive feedback, random number..." />
        <meta http-equiv="Content-Type" CONTENT="text/html; charset="utf-8" />
        <title>initstate, random, setstate, srandom, srandomdev -- better random number</title>
        <META NAME="robots" CONTENT="all" />
    </head>
    
<body><pre>

RANDOM(3)		 BSD Library Functions Manual		     RANDOM(3)

NAME
     initstate, random, setstate, srandom, srandomdev -- better random number
     generator; routines for changing generators

LIBRARY
     Standard C Library (libc, -lc)

SYNOPSIS
     #include <stdlib.h>

     char *
     initstate(unsigned seed, char *state, size_t size);

     long
     random(void);

     char *
     setstate(const char *state);

     void
     srandom(unsigned seed);

     void
     srandomdev(void);

DESCRIPTION
     The random() function uses a non-linear, additive feedback, random number
     generator, employing a default table of size 31 long integers.  It
     returns successive pseudo-random numbers in the range from 0 to
     (2**31)-1.  The period of this random number generator is very large,
     approximately 16*((2**31)-1).

     The random() and srandom() functions have (almost) the same calling
     sequence and initialization properties as the rand(3) and srand(3) func-
     tions.  The difference is that rand(3) produces a much less random
     sequence -- in fact, the low dozen bits generated by rand go through a
     cyclic pattern.  All of the bits generated by random() are usable.  For
     example, `random()&01' will produce a random binary value.

     Like srand(3), srandom() sets the initial seed value for future calls to
     random().	Like rand(3), random() will by default produce a sequence of
     numbers that can be duplicated by calling srandom() with the same seed.

     The srandomdev() routine initializes a state array, using the random(4)
     random number device which returns good random numbers, suitable for
     cryptographic use.  Note that this particular seeding procedure can gen-
     erate states which are impossible to reproduce by calling srandom() with
     any value, since the succeeding terms in the state buffer are no longer
     derived from the LC algorithm applied to a fixed seed.

     The initstate() routine allows a state array, passed in as an argument,
     to be initialized for future use.	The size of the state array (in bytes)
     is used by initstate() to decide how sophisticated a random number gener-
     ator it should use -- the more state, the better the random numbers will
     be.  (Current "optimal" values for the amount of state information are 8,
     32, 64, 128, and 256 bytes; other amounts will be rounded down to the
     nearest known amount.  Using less than 8 bytes will cause an error.)  The
     seed for the initialization (which specifies a starting point for the
     random number sequence and provides for restarting at the same point) is
     also an argument.	The initstate() function returns a pointer to the pre-
     vious state information array.

     Once a state has been initialized, the setstate() routine provides for
     rapid switching between states.  The setstate() function returns a
     pointer to the previous state array; its argument state array is used for
     further random number generation until the next call to initstate() or
     setstate().

     Once a state array has been initialized, it may be restarted at a differ-
     ent point either by calling initstate() (with the desired seed, the state
     array, and its size) or by calling both setstate() (with the state array)
     and srandom() (with the desired seed).  The advantage of calling both
     setstate() and srandom() is that the size of the state array does not
     have to be remembered after it is initialized.

     With 256 bytes of state information, the period of the random number gen-
     erator is greater than 2**69 , which should be sufficient for most pur-
     poses.

DIAGNOSTICS
     If initstate() is called with less than 8 bytes of state information, or
     if setstate() detects that the state information has been garbled, error
     messages are printed on the standard error output.

LEGACY SYNOPSIS
     #include <stdlib.h>

     char *
     initstate(unsigned long seed, char *state, long size);

     char *
     setstate(char *state);

     void
     srandom(unsigned long seed);

     The type of each parameter is different in the legacy version.

SEE ALSO
     arc4random(3), rand(3), srand(3), random(4), compat(5)

HISTORY
     These functions appeared in 4.2BSD.

AUTHORS
     Earl T. Cohen

BUGS
     About 2/3 the speed of rand(3).

     The historical implementation used to have a very weak seeding; the ran-
     dom sequence did not vary much with the seed.  The current implementation
     employs a better pseudo-random number generator for the initial state
     calculation.

     Applications requiring cryptographic quality randomness should use
     arc4random(3).

BSD				 June 4, 1993				   BSD
    </pre><script type="text/javascript" src="../js/ga.js"></script></body>

</html>
