<!DOCTYPE html>
<html>
    <head>
        <meta name="description" content="IO::Pager is designed to programmaticly decide whether or not to point..." />
        <meta http-equiv="Content-Type" CONTENT="text/html; charset="utf-8" />
        <script type="text/javascript" src="../js/ga.js"></script>
        <title>IO::Pager::Buffered - Pipe deferred output to a pager if output is to a</title>
        <META NAME="robots" CONTENT="all" />
    </head>
    
<body><pre>

IO::Pager::Buffered(3)User Contributed Perl DocumentatioIO::Pager::Buffered(3)



NAME
       IO::Pager::Buffered - Pipe deferred output to a pager if output is to a
       TTY

SYNOPSIS
	 use IO::Pager::Buffered;
	 {
	   #local $STDOUT =	IO::Pager::Buffered::open *STDOUT;
	   local  $STDOUT = new IO::Pager::Buffered	  *STDOUT;
	   print &lt&lt"  HEREDOC" ;
	   ...
	   A bunch of text later
	   HEREDOC
	 }

DESCRIPTION
       IO::Pager is designed to programmaticly decide whether or not to point
       the STDOUT file handle into a pipe to program specified in $ENV{PAGER}
       or one of a standard list of pagers.

       This subclass buffers all output for display upon exiting the current
       scope.  If this is not what you want look at another subclass such as
       IO::Pager::Unbuffered. While probably not common, this may be useful in
       some cases,such as buffering all output to STDOUT while the process
       occurs, showing only warnings on STDERR, then displaying the output to
       STDOUT after.  Or alternately letting output to STDERR slide by and
       defer warnings for later perusal.

   new( [FILEHANDLE] )
       Instantiate a new IO::Pager to paginate FILEHANDLE if necessary.
       Assign the return value to a scoped variable. Output does not occur
       until all references to this variable are destroyed eg; upon leaving
       the current scope. See "DESCRIPTION".

       FILEHANDLE
	   Defaults to currently select()-ed FILEHANDLE.

   open( [FILEHANDLE] )
       An alias for new.

   close( FILEHANDLE )
       Explicitly close the filehandle, this stops collecting and displays the
       output, executing a pager if necessary. Normally you'd just wait for
       the object to pass out of scope.

       This does not default to the current filehandle.

CAVEATS
       If you mix buffered and unbuffered operations the output order is
       unspecified, and will probably differ for a TTY vs. a file. See
       perlfunc.

       $, is used see perlvar.

SEE ALSO
       IO::Pager, IO::Pager::Unbuffered, IO::Pager::Page

AUTHOR
       Jerrad Pierce &ltjpierce@cpan.org&gt

       This module is forked from IO::Page 0.02 by Monte Mitzelfelt

LICENSE
       o   Thou shalt not claim ownership of unmodified materials.

       o   Thou shalt not claim whole ownership of modified materials.

       o   Thou shalt grant the indemnity of the provider of materials.

       o   Thou shalt use and dispense freely without other restrictions.



perl v5.10.1			  2004-11-17		IO::Pager::Buffered(3)
    </pre></body>

</html>
