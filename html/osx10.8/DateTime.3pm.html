<!DOCTYPE html>
<html>
    <head>
        <meta name="description" content="DateTime is a class for the representation of date/time combinations,..." />
        <meta http-equiv="Content-Type" CONTENT="text/html; charset="utf-8" />
        <script type="text/javascript" src="../js/ga.js"></script>
        <title>DateTime - A date and time object</title>
        <META NAME="robots" CONTENT="all" />
    </head>
    
<body><pre>

DateTime(3)	      User Contributed Perl Documentation	   DateTime(3)



NAME
       DateTime - A date and time object

VERSION
       version 0.70

SYNOPSIS
	 use DateTime;

	 $dt = DateTime-&gtnew(
	     year	=&gt 1964,
	     month	=&gt 10,
	     day	=&gt 16,
	     hour	=&gt 16,
	     minute	=&gt 12,
	     second	=&gt 47,
	     nanosecond =&gt 500000000,
	     time_zone	=&gt 'Asia/Taipei',
	 );

	 $dt = DateTime-&gtfrom_epoch( epoch =&gt $epoch );
	 $dt = DateTime-&gtnow; # same as ( epoch =&gt time() )

	 $year	 = $dt-&gtyear;
	 $month  = $dt-&gtmonth;		# 1-12

	 $day	 = $dt-&gtday;		# 1-31

	 $dow	 = $dt-&gtday_of_week;	# 1-7 (Monday is 1)

	 $hour	 = $dt-&gthour;		# 0-23
	 $minute = $dt-&gtminute; 	# 0-59

	 $second = $dt-&gtsecond; 	# 0-61 (leap seconds!)

	 $doy	 = $dt-&gtday_of_year;	# 1-366 (leap years)

	 $doq	 = $dt-&gtday_of_quarter; # 1..

	 $qtr	 = $dt-&gtquarter;	# 1-4

	 # all of the start-at-1 methods above have corresponding start-at-0
	 # methods, such as $dt-&gtday_of_month_0, $dt-&gtmonth_0 and so on

	 $ymd	 = $dt-&gtymd;	       # 2002-12-06
	 $ymd	 = $dt-&gtymd('/');      # 2002/12/06

	 $mdy	 = $dt-&gtmdy;	       # 12-06-2002
	 $mdy	 = $dt-&gtmdy('/');      # 12/06/2002

	 $dmy	 = $dt-&gtdmy;	       # 06-12-2002
	 $dmy	 = $dt-&gtdmy('/');      # 06/12/2002

	 $hms	 = $dt-&gthms;	       # 14:02:29
	 $hms	 = $dt-&gthms('!');      # 14!02!29

	 $is_leap  = $dt-&gtis_leap_year;

	 # these are localizable, see Locales section
	 $month_name  = $dt-&gtmonth_name; # January, February, ...
	 $month_abbr  = $dt-&gtmonth_abbr; # Jan, Feb, ...
	 $day_name    = $dt-&gtday_name;	 # Monday, Tuesday, ...
	 $day_abbr    = $dt-&gtday_abbr;	 # Mon, Tue, ...

	 # May not work for all possible datetime, see the docs on this
	 # method for more details.
	 $epoch_time  = $dt-&gtepoch;

	 $dt2 = $dt + $duration_object;

	 $dt3 = $dt - $duration_object;

	 $duration_object = $dt - $dt2;

	 $dt-&gtset( year =&gt 1882 );

	 $dt-&gtset_time_zone( 'America/Chicago' );

	 $dt-&gtset_formatter( $formatter );

DESCRIPTION
       DateTime is a class for the representation of date/time combinations,
       and is part of the Perl DateTime project. For details on this project
       please see &lthttp://datetime.perl.org/&gt. The DateTime site has a FAQ
       which may help answer many "how do I do X?" questions. The FAQ is at
       &lthttp://datetime.perl.org/wiki/datetime/page/FAQ&gt.

       It represents the Gregorian calendar, extended backwards in time before
       its creation (in 1582). This is sometimes known as the "proleptic
       Gregorian calendar". In this calendar, the first day of the calendar
       (the epoch), is the first day of year 1, which corresponds to the date
       which was (incorrectly) believed to be the birth of Jesus Christ.

       The calendar represented does have a year 0, and in that way differs
       from how dates are often written using "BCE/CE" or "BC/AD".

       For infinite datetimes, please see the DateTime::Infinite module.

USAGE
   0-based Versus 1-based Numbers
       The DateTime.pm module follows a simple consistent logic for
       determining whether or not a given number is 0-based or 1-based.

       Month, day of month, day of week, and day of year are 1-based. Any
       method that is 1-based also has an equivalent 0-based method ending in
       "_0". So for example, this class provides both "day_of_week()" and
       "day_of_week_0()" methods.

       The "day_of_week_0()" method still treats Monday as the first day of
       the week.

       All time-related numbers such as hour, minute, and second are 0-based.

       Years are neither, as they can be both positive or negative, unlike any
       other datetime component. There is a year 0.

       There is no "quarter_0()" method.

   Error Handling
       Some errors may cause this module to die with an error string. This can
       only happen when calling constructor methods, methods that change the
       object, such as "set()", or methods that take parameters.  Methods that
       retrieve information about the object, such as "year()" or "epoch()",
       will never die.

   Locales
       All the object methods which return names or abbreviations return data
       based on a locale. This is done by setting the locale when constructing
       a DateTime object. There is also a "DefaultLocale()" class method which
       may be used to set the default locale for all DateTime objects created.
       If this is not set, then "en_US" is used.

   Floating DateTimes
       The default time zone for new DateTime objects, except where stated
       otherwise, is the "floating" time zone. This concept comes from the
       iCal standard. A floating datetime is one which is not anchored to any
       particular time zone. In addition, floating datetimes do not include
       leap seconds, since we cannot apply them without knowing the datetime's
       time zone.

       The results of date math and comparison between a floating datetime and
       one with a real time zone are not really valid, because one includes
       leap seconds and the other does not. Similarly, the results of datetime
       math between two floating datetimes and two datetimes with time zones
       are not really comparable.

       If you are planning to use any objects with a real time zone, it is
       strongly recommended that you do not mix these with floating datetimes.

   Math
       If you are going to be using doing date math, please read the section
       "How Datetime Math Works".

   Time Zone Warnings
       Determining the local time zone for a system can be slow. If $ENV{TZ}
       is not set, it may involve reading a number of files in /etc or
       elsewhere. If you know that the local time zone won't change while your
       code is running, and you need to make many objects for the local time
       zone, it is strongly recommended that you retrieve the local time zone
       once and cache it:

	 our $App::LocalTZ = DateTime::TimeZone-&gtnew( name =&gt 'local' );

	 ... # then everywhere else

	 my $dt = DateTime-&gtnew( ..., time_zone =&gt $App::LocalTZ );

       DateTime itself does not do this internally because local time zones
       can change, and there's no good way to determine if it's changed
       without doing all the work to look it up.

       Do not try to use named time zones (like "America/Chicago") with dates
       very far in the future (thousands of years). The current implementation
       of "DateTime::TimeZone" will use a huge amount of memory calculating
       all the DST changes from now until the future date. Use UTC or the
       floating time zone and you will be safe.

   Methods
       Constructors

       All constructors can die when invalid parameters are given.

       o   DateTime-&gtnew( ... )

	   This class method accepts parameters for each date and time
	   component: "year", "month", "day", "hour", "minute", "second",
	   "nanosecond".  It also accepts "locale", "time_zone", and
	   "formatter" parameters.

	     my $dt = DateTime-&gtnew(
		 year	    =&gt 1966,
		 month	    =&gt 10,
		 day	    =&gt 25,
		 hour	    =&gt 7,
		 minute     =&gt 15,
		 second     =&gt 47,
		 nanosecond =&gt 500000000,
		 time_zone  =&gt 'America/Chicago',
	     );

	   DateTime validates the "month", "day", "hour", "minute", and
	   "second", and "nanosecond" parameters. The valid values for these
	   parameters are:

	   o	   month

		   An integer from 1-12.

	   o	   day

		   An integer from 1-31, and it must be within the valid range
		   of days for the specified month.

	   o	   hour

		   An integer from 0-23.

	   o	   minute

		   An integer from 0-59.

	   o	   second

		   An integer from 0-61 (to allow for leap seconds). Values of
		   60 or 61 are only allowed when they match actual leap
		   seconds.

	   o	   nanosecond

		   An integer &gt= 0. If this number is greater than 1 billion,
		   it will be normalized into the second value for the
		   DateTime object.

	   Invalid parameter types (like an array reference) will cause the
	   constructor to die.

	   The value for seconds may be from 0 to 61, to account for leap
	   seconds. If you give a value greater than 59, DateTime does check
	   to see that it really matches a valid leap second.

	   All of the parameters are optional except for "year". The "month"
	   and "day" parameters both default to 1, while the "hour", "minute",
	   "second", and "nanosecond" parameters all default to 0.

	   The "locale" parameter should be a string matching one of the valid
	   locales, or a "DateTime::Locale" object. See the DateTime::Locale
	   documentation for details.

	   The time_zone parameter can be either a scalar or a
	   "DateTime::TimeZone" object. A string will simply be passed to the
	   "DateTime::TimeZone-&gtnew" method as its "name" parameter. This
	   string may be an Olson DB time zone name ("America/Chicago"), an
	   offset string ("+0630"), or the words "floating" or "local". See
	   the "DateTime::TimeZone" documentation for more details.

	   The default time zone is "floating".

	   The "formatter" can be either a scalar or an object, but the class
	   specified by the scalar or the object must implement a
	   "format_datetime()" method.

       Parsing Dates

       This module does not parse dates! That means there is no constructor to
       which you can pass things like "March 3, 1970 12:34".

       Instead, take a look at the various "DateTime::Format::*" modules on
       CPAN. These parse all sorts of different date formats, and you're bound
       to find something that can handle your particular needs.

       Ambiguous Local Times

       Because of Daylight Saving Time, it is possible to specify a local time
       that is ambiguous. For example, in the US in 2003, the transition from
       to saving to standard time occurred on October 26, at 02:00:00 local
       time. The local clock changed from 01:59:59 (saving time) to 01:00:00
       (standard time). This means that the hour from 01:00:00 through
       01:59:59 actually occurs twice, though the UTC time continues to move
       forward.

       If you specify an ambiguous time, then the latest UTC time is always
       used, in effect always choosing standard time. In this case, you can
       simply subtract an hour to the object in order to move to saving time,
       for example:

	 # This object represent 01:30:00 standard time
	 my $dt = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 10,
	     day       =&gt 26,
	     hour      =&gt 1,
	     minute    =&gt 30,
	     second    =&gt 0,
	     time_zone =&gt 'America/Chicago',
	 );

	 print $dt-&gthms;  # prints 01:30:00

	 # Now the object represent 01:30:00 saving time
	 $dt-&gtsubtract( hours =&gt 1 );

	 print $dt-&gthms;  # still prints 01:30:00

       Alternately, you could create the object with the UTC time zone, and
       then call the "set_time_zone()" method to change the time zone. This is
       a good way to ensure that the time is not ambiguous.

       Invalid Local Times

       Another problem introduced by Daylight Saving Time is that certain
       local times just do not exist. For example, in the US in 2003, the
       transition from standard to saving time occurred on April 6, at the
       change to 2:00:00 local time. The local clock changes from 01:59:59
       (standard time) to 03:00:00 (saving time). This means that there is no
       02:00:00 through 02:59:59 on April 6!

       Attempting to create an invalid time currently causes a fatal error.
       This may change in future version of this module.

       o   DateTime-&gtfrom_epoch( epoch =&gt $epoch, ... )

	   This class method can be used to construct a new DateTime object
	   from an epoch time instead of components. Just as with the "new()"
	   method, it accepts "time_zone", "locale", and "formatter"
	   parameters.

	   If the epoch value is not an integer, the part after the decimal
	   will be converted to nanoseconds. This is done in order to be
	   compatible with "Time::HiRes". If the floating portion extends past
	   9 decimal places, it will be truncated to nine, so that
	   1.1234567891 will become 1 second and 123,456,789 nanoseconds.

	   By default, the returned object will be in the UTC time zone.

       o   DateTime-&gtnow( ... )

	   This class method is equivalent to calling "from_epoch()" with the
	   value returned from Perl's "time()" function. Just as with the
	   "new()" method, it accepts "time_zone" and "locale" parameters.

	   By default, the returned object will be in the UTC time zone.

       o   DateTime-&gttoday( ... )

	   This class method is equivalent to:

	     DateTime-&gtnow-&gttruncate( to =&gt 'day' );

       o   DateTime-&gtfrom_object( object =&gt $object, ... )

	   This class method can be used to construct a new DateTime object
	   from any object that implements the "utc_rd_values()" method. All
	   "DateTime::Calendar" modules must implement this method in order to
	   provide cross-calendar compatibility. This method accepts a
	   "locale" and "formatter" parameter

	   If the object passed to this method has a "time_zone()" method,
	   that is used to set the time zone of the newly created
	   "DateTime.pm" object.

	   Otherwise, the returned object will be in the floating time zone.

       o   DateTime-&gtlast_day_of_month( ... )

	   This constructor takes the same arguments as can be given to the
	   "new()" method, except for "day". Additionally, both "year" and
	   "month" are required.

       o   DateTime-&gtfrom_day_of_year( ... )

	   This constructor takes the same arguments as can be given to the
	   "new()" method, except that it does not accept a "month" or "day"
	   argument. Instead, it requires both "year" and "day_of_year". The
	   day of year must be between 1 and 366, and 366 is only allowed for
	   leap years.

       o   $dt-&gtclone()

	   This object method returns a new object that is replica of the
	   object upon which the method is called.

       "Get" Methods

       This class has many methods for retrieving information about an object.

       o   $dt-&gtyear()

	   Returns the year.

       o   $dt-&gtce_year()

	   Returns the year according to the BCE/CE numbering system. The year
	   before year 1 in this system is year -1, aka "1 BCE".

       o   $dt-&gtera_name()

	   Returns the long name of the current era, something like "Before
	   Christ". See the Locales section for more details.

       o   $dt-&gtera_abbr()

	   Returns the abbreviated name of the current era, something like
	   "BC".  See the Locales section for more details.

       o   $dt-&gtchristian_era()

	   Returns a string, either "BC" or "AD", according to the year.

       o   $dt-&gtsecular_era()

	   Returns a string, either "BCE" or "CE", according to the year.

       o   $dt-&gtyear_with_era()

	   Returns a string containing the year immediately followed by its
	   era abbreviation. The year is the absolute value of "ce_year()", so
	   that year 1 is "1AD" and year 0 is "1BC".

       o   $dt-&gtyear_with_christian_era()

	   Like "year_with_era()", but uses the christian_era() to get the era
	   name.

       o   $dt-&gtyear_with_secular_era()

	   Like "year_with_era()", but uses the secular_era() method to get
	   the era name.

       o   $dt-&gtmonth()

	   Returns the month of the year, from 1..12.

	   Also available as "$dt-&gtmon()".

       o   $dt-&gtmonth_name()

	   Returns the name of the current month. See the Locales section for
	   more details.

       o   $dt-&gtmonth_abbr()

	   Returns the abbreviated name of the current month. See the Locales
	   section for more details.

       o   $dt-&gtday()

	   Returns the day of the month, from 1..31.

	   Also available as "$dt-&gtmday()" and "$dt-&gtday_of_month()".

       o   $dt-&gtday_of_week()

	   Returns the day of the week as a number, from 1..7, with 1 being
	   Monday and 7 being Sunday.

	   Also available as "$dt-&gtwday()" and "$dt-&gtdow()".

       o   $dt-&gtlocal_day_of_week()

	   Returns the day of the week as a number, from 1..7. The day
	   corresponding to 1 will vary based on the locale.

       o   $dt-&gtday_name()

	   Returns the name of the current day of the week. See the Locales
	   section for more details.

       o   $dt-&gtday_abbr()

	   Returns the abbreviated name of the current day of the week. See
	   the Locales section for more details.

       o   $dt-&gtday_of_year()

	   Returns the day of the year.

	   Also available as "$dt-&gtdoy()".

       o   $dt-&gtquarter()

	   Returns the quarter of the year, from 1..4.

       o   $dt-&gtquarter_name()

	   Returns the name of the current quarter. See the Locales section
	   for more details.

       o   $dt-&gtquarter_abbr()

	   Returns the abbreviated name of the current quarter. See the
	   Locales section for more details.

       o   $dt-&gtday_of_quarter()

	   Returns the day of the quarter.

	   Also available as "$dt-&gtdoq()".

       o   $dt-&gtweekday_of_month()

	   Returns a number from 1..5 indicating which week day of the month
	   this is. For example, June 9, 2003 is the second Monday of the
	   month, and so this method returns 2 for that day.

       o   $dt-&gtymd( $optional_separator )

       o   $dt-&gtmdy( $optional_separator )

       o   $dt-&gtdmy( $optional_separator )

	   Each method returns the year, month, and day, in the order
	   indicated by the method name. Years are zero-padded to four digits.
	   Months and days are 0-padded to two digits.

	   By default, the values are separated by a dash (-), but this can be
	   overridden by passing a value to the method.

	   The "$dt-&gtymd()" method is also available as "$dt-&gtdate()".

       o   $dt-&gthour()

	   Returns the hour of the day, from 0..23.

       o   $dt-&gthour_1()

	   Returns the hour of the day, from 1..24.

       o   $dt-&gthour_12()

	   Returns the hour of the day, from 1..12.

       o   $dt-&gthour_12_0()

	   Returns the hour of the day, from 0..11.

       o   $dt-&gtam_or_pm()

	   Returns the appropriate localized abbreviation, depending on the
	   current hour.

       o   $dt-&gtminute()

	   Returns the minute of the hour, from 0..59.

	   Also available as "$dt-&gtmin()".

       o   $dt-&gtsecond()

	   Returns the second, from 0..61. The values 60 and 61 are used for
	   leap seconds.

	   Also available as "$dt-&gtsec()".

       o   $dt-&gtfractional_second()

	   Returns the second, as a real number from 0.0 until 61.999999999

	   The values 60 and 61 are used for leap seconds.

       o   $dt-&gtmillisecond()

	   Returns the fractional part of the second as milliseconds (1E-3
	   seconds).

	   Half a second is 500 milliseconds.

       o   $dt-&gtmicrosecond()

	   Returns the fractional part of the second as microseconds (1E-6
	   seconds). This value will be rounded to an integer.

	   Half a second is 500_000 microseconds. This value will be rounded
	   to an integer.

       o   $dt-&gtnanosecond()

	   Returns the fractional part of the second as nanoseconds (1E-9
	   seconds).

	   Half a second is 500_000_000 nanoseconds.

       o   $dt-&gthms( $optional_separator )

	   Returns the hour, minute, and second, all zero-padded to two
	   digits.  If no separator is specified, a colon (:) is used by
	   default.

	   Also available as "$dt-&gttime()".

       o   $dt-&gtdatetime()

	   This method is equivalent to:

	     $dt-&gtymd('-') . 'T' . $dt-&gthms(':')

	   Also available as "$dt-&gtiso8601()".

       o   $dt-&gtis_leap_year()

	   This method returns a true or false indicating whether or not the
	   datetime object is in a leap year.

       o   $dt-&gtweek()

	    ($week_year, $week_number) = $dt-&gtweek;

	   Returns information about the calendar week which contains this
	   datetime object. The values returned by this method are also
	   available separately through the week_year and week_number methods.

	   The first week of the year is defined by ISO as the one which
	   contains the fourth day of January, which is equivalent to saying
	   that it's the first week to overlap the new year by at least four
	   days.

	   Typically the week year will be the same as the year that the
	   object is in, but dates at the very beginning of a calendar year
	   often end up in the last week of the prior year, and similarly, the
	   final few days of the year may be placed in the first week of the
	   next year.

       o   $dt-&gtweek_year()

	   Returns the year of the week. See "$dt-&gtweek()" for details.

       o   $dt-&gtweek_number()

	   Returns the week of the year, from 1..53. See "$dt-&gtweek()" for
	   details.

       o   $dt-&gtweek_of_month()

	   The week of the month, from 0..5. The first week of the month is
	   the first week that contains a Thursday. This is based on the ICU
	   definition of week of month, and correlates to the ISO8601 week of
	   year definition. A day in the week before the week with the first
	   Thursday will be week 0.

       o   $dt-&gtjd()

       o   $dt-&gtmjd()

	   These return the Julian Day and Modified Julian Day, respectively.
	   The value returned is a floating point number. The fractional
	   portion of the number represents the time portion of the datetime.

       o   $dt-&gttime_zone()

	   This returns the "DateTime::TimeZone" object for the datetime
	   object.

       o   $dt-&gtoffset()

	   This returns the offset from UTC, in seconds, of the datetime
	   object according to the time zone.

       o   $dt-&gtis_dst()

	   Returns a boolean indicating whether or not the datetime object is
	   currently in Daylight Saving Time or not.

       o   $dt-&gttime_zone_long_name()

	   This is a shortcut for "$dt-&gttime_zone-&gtname". It's provided so
	   that one can use "%{time_zone_long_name}" as a strftime format
	   specifier.

       o   $dt-&gttime_zone_short_name()

	   This method returns the time zone abbreviation for the current time
	   zone, such as "PST" or "GMT". These names are not definitive, and
	   should not be used in any application intended for general use by
	   users around the world.

       o   $dt-&gtstrftime( $format, ... )

	   This method implements functionality similar to the "strftime()"
	   method in C. However, if given multiple format strings, then it
	   will return multiple scalars, one for each format string.

	   See the "strftime Patterns" section for a list of all possible
	   strftime patterns.

	   If you give a pattern that doesn't exist, then it is simply treated
	   as text.

       o   $dt-&gtformat_cldr( $format, ... )

	   This method implements formatting based on the CLDR date patterns.
	   If given multiple format strings, then it will return multiple
	   scalars, one for each format string.

	   See the "CLDR Patterns" section for a list of all possible CLDR
	   patterns.

	   If you give a pattern that doesn't exist, then it is simply treated
	   as text.

       o   $dt-&gtepoch()

	   Return the UTC epoch value for the datetime object. Internally,
	   this is implemented using "Time::Local", which uses the Unix epoch
	   even on machines with a different epoch (such as MacOS). Datetimes
	   before the start of the epoch will be returned as a negative
	   number.

	   The return value from this method is always an integer.

	   Since the epoch does not account for leap seconds, the epoch time
	   for 1972-12-31T23:59:60 (UTC) is exactly the same as that for
	   1973-01-01T00:00:00.

	   This module uses "Time::Local" to calculate the epoch, which may or
	   may not handle epochs before 1904 or after 2038 (depending on the
	   size of your system's integers, and whether or not Perl was
	   compiled with 64-bit int support).

       o   $dt-&gthires_epoch()

	   Returns the epoch as a floating point number. The floating point
	   portion of the value represents the nanosecond value of the object.
	   This method is provided for compatibility with the "Time::HiRes"
	   module.

       o   $dt-&gtis_finite()

       o   $dt-&gtis_infinite()

	   These methods allow you to distinguish normal datetime objects from
	   infinite ones. Infinite datetime objects are documented in
	   DateTime::Infinite.

       o   $dt-&gtutc_rd_values()

	   Returns the current UTC Rata Die days, seconds, and nanoseconds as
	   a three element list. This exists primarily to allow other calendar
	   modules to create objects based on the values provided by this
	   object.

       o   $dt-&gtlocal_rd_values()

	   Returns the current local Rata Die days, seconds, and nanoseconds
	   as a three element list. This exists for the benefit of other
	   modules which might want to use this information for date math,
	   such as "DateTime::Event::Recurrence".

       o   $dt-&gtleap_seconds()

	   Returns the number of leap seconds that have happened up to the
	   datetime represented by the object. For floating datetimes, this
	   always returns 0.

       o   $dt-&gtutc_rd_as_seconds()

	   Returns the current UTC Rata Die days and seconds purely as
	   seconds.  This number ignores any fractional seconds stored in the
	   object, as well as leap seconds.

       o   $dt-&gtlocale()

	   Returns the current locale object.

       o   $dt-&gtformatter()

	   Returns current formatter object or class. See "Formatters And
	   Stringification" for details.

       "Set" Methods

       The remaining methods provided by "DateTime.pm", except where otherwise
       specified, return the object itself, thus making method chaining
       possible. For example:

	 my $dt = DateTime-&gtnow-&gtset_time_zone( 'Australia/Sydney' );

	 my $first = DateTime
		       -&gtlast_day_of_month( year =&gt 2003, month =&gt 3 )
		       -&gtadd( days =&gt 1 )
		       -&gtsubtract( seconds =&gt 1 );

       o   $dt-&gtset( .. )

	   This method can be used to change the local components of a date
	   time, or its locale. This method accepts any parameter allowed by
	   the "new()" method except for "time_zone". Time zones may be set
	   using the "set_time_zone()" method.

	   This method performs parameters validation just as is done in the
	   "new()" method.

       o   $dt-&gtset_year()

       o   $dt-&gtset_month()

       o   $dt-&gtset_day()

       o   $dt-&gtset_hour()

       o   $dt-&gtset_minute()

       o   $dt-&gtset_second()

       o   $dt-&gtset_nanosecond()

       o   $dt-&gtset_locale()

	   These are shortcuts to calling "set()" with a single key. They all
	   take a single parameter.

       o   $dt-&gttruncate( to =&gt ... )

	   This method allows you to reset some of the local time components
	   in the object to their "zero" values. The "to" parameter is used to
	   specify which values to truncate, and it may be one of "year",
	   "month", "week", "day", "hour", "minute", or "second". For example,
	   if "month" is specified, then the local day becomes 1, and the
	   hour, minute, and second all become 0.

	   If "week" is given, then the datetime is set to the beginning of
	   the week in which it occurs, and the time components are all set to
	   0.

       o   $dt-&gtset_time_zone( $tz )

	   This method accepts either a time zone object or a string that can
	   be passed as the "name" parameter to "DateTime::TimeZone-&gtnew()".
	   If the new time zone's offset is different from the old time zone,
	   then the local time is adjusted accordingly.

	   For example:

	     my $dt = DateTime-&gtnew(
		 year	   =&gt 2000,
		 month	   =&gt 5,
		 day	   =&gt 10,
		 hour	   =&gt 15,
		 minute    =&gt 15,
		 time_zone =&gt 'America/Los_Angeles',
	     );

	     print $dt-&gthour; # prints 15

	     $dt-&gtset_time_zone( 'America/Chicago' );

	     print $dt-&gthour; # prints 17

	   If the old time zone was a floating time zone, then no adjustments
	   to the local time are made, except to account for leap seconds. If
	   the new time zone is floating, then the UTC time is adjusted in
	   order to leave the local time untouched.

	   Fans of Tsai Ming-Liang's films will be happy to know that this
	   does work:

	     my $dt = DateTime-&gtnow( time_zone =&gt 'Asia/Taipei' );

	     $dt-&gtset_time_zone( 'Europe/Paris' );

	   Yes, now we can know "ni3 na4 bian1 ji2dian3?"

       o   $dt-&gtset_formatter( $formatter )

	   Set the formatter for the object. See "Formatters And
	   Stringification" for details.

	   You can set this to "undef" to revert to the default formatter.

       Math Methods

       Like the set methods, math related methods always return the object
       itself, to allow for chaining:

	 $dt-&gtadd( days =&gt 1 )-&gtsubtract( seconds =&gt 1 );

       o   $dt-&gtduration_class()

	   This returns "DateTime::Duration", but exists so that a subclass of
	   "DateTime.pm" can provide a different value.

       o   $dt-&gtadd_duration( $duration_object )

	   This method adds a "DateTime::Duration" to the current datetime.
	   See the DateTime::Duration docs for more details.

       o   $dt-&gtadd( DateTime::Duration-&gtnew parameters )

	   This method is syntactic sugar around the "add_duration()" method.
	   It simply creates a new "DateTime::Duration" object using the
	   parameters given, and then calls the "add_duration()" method.

       o   $dt-&gtsubtract_duration( $duration_object )

	   When given a "DateTime::Duration" object, this method simply calls
	   "invert()" on that object and passes that new duration to the
	   "add_duration" method.

       o   $dt-&gtsubtract( DateTime::Duration-&gtnew parameters )

	   Like "add()", this is syntactic sugar for the "subtract_duration()"
	   method.

       o   $dt-&gtsubtract_datetime( $datetime )

	   This method returns a new "DateTime::Duration" object representing
	   the difference between the two dates. The duration is relative to
	   the object from which $datetime is subtracted. For example:

	       2003-03-15 00:00:00.00000000
	    -  2003-02-15 00:00:00.00000000
	    -------------------------------
	    = 1 month

	   Note that this duration is not an absolute measure of the amount of
	   time between the two datetimes, because the length of a month
	   varies, as well as due to the presence of leap seconds.

	   The returned duration may have deltas for months, days, minutes,
	   seconds, and nanoseconds.

       o   $dt-&gtdelta_md( $datetime )

       o   $dt-&gtdelta_days( $datetime )

	   Each of these methods returns a new "DateTime::Duration" object
	   representing some portion of the difference between two datetimes.
	   The "delta_md()" method returns a duration which contains only the
	   month and day portions of the duration is represented. The
	   "delta_days()" method returns a duration which contains only days.

	   The "delta_md" and "delta_days" methods truncate the duration so
	   that any fractional portion of a day is ignored. Both of these
	   methods operate on the date portion of a datetime only, and so
	   effectively ignore the time zone.

	   Unlike the subtraction methods, these methods always return a
	   positive (or zero) duration.

       o   $dt-&gtdelta_ms( $datetime )

	   Returns a duration which contains only minutes and seconds. Any day
	   and month differences to minutes are converted to minutes and
	   seconds. This method also always return a positive (or zero)
	   duration.

       o   $dt-&gtsubtract_datetime_absolute( $datetime )

	   This method returns a new "DateTime::Duration" object representing
	   the difference between the two dates in seconds and nanoseconds.
	   This is the only way to accurately measure the absolute amount of
	   time between two datetimes, since units larger than a second do not
	   represent a fixed number of seconds.

       Class Methods

       o   DateTime-&gtDefaultLocale( $locale )

	   This can be used to specify the default locale to be used when
	   creating DateTime objects. If unset, then "en_US" is used.

       o   DateTime-&gtcompare( $dt1, $dt2 )

       o   DateTime-&gtcompare_ignore_floating( $dt1, $dt2 )

	     $cmp = DateTime-&gtcompare( $dt1, $dt2 );

	     $cmp = DateTime-&gtcompare_ignore_floating( $dt1, $dt2 );

	   Compare two DateTime objects. The semantics are compatible with
	   Perl's "sort()" function; it returns -1 if $dt1 &lt $dt2, 0 if $dt1
	   == $dt2, 1 if $dt1 &gt $dt2.

	   If one of the two DateTime objects has a floating time zone, it
	   will first be converted to the time zone of the other object. This
	   is what you want most of the time, but it can lead to inconsistent
	   results when you compare a number of DateTime objects, some of
	   which are floating, and some of which are in other time zones.

	   If you want to have consistent results (because you want to sort a
	   number of objects, for example), you can use the
	   "compare_ignore_floating()" method:

	     @dates = sort { DateTime-&gtcompare_ignore_floating($a, $b) } @dates;

	   In this case, objects with a floating time zone will be sorted as
	   if they were UTC times.

	   Since DateTime objects overload comparison operators, this:

	     @dates = sort @dates;

	   is equivalent to this:

	     @dates = sort { DateTime-&gtcompare($a, $b) } @dates;

	   DateTime objects can be compared to any other calendar class that
	   implements the "utc_rd_values()" method.

   How Datetime Math Works
       It's important to have some understanding of how datetime math is
       implemented in order to effectively use this module and
       "DateTime::Duration".

       Making Things Simple

       If you want to simplify your life and not have to think too hard about
       the nitty-gritty of datetime math, I have several recommendations:

       o   use the floating time zone

	   If you do not care about time zones or leap seconds, use the
	   "floating" timezone:

	     my $dt = DateTime-&gtnow( time_zone =&gt 'floating' );

	   Math done on two objects in the floating time zone produces very
	   predictable results.

	   Note that in most cases you will want to start by creating an
	   object in a specific zone and then convert it to the floating time
	   zone. When an object goes from a real zone to the floating zone,
	   the time for the object remains the same.

	   This means that passing the floating zone to a constructor may not
	   do what you want.

	     my $dt = DateTime-&gtnow( time_zone =&gt 'floating' );

	   is equivalent to

	     my $dt = DateTime-&gtnow( time_zone =&gt 'UTC' )-&gtset_time_zone('floating');

	   This might not be what you wanted. Instead, you may prefer to do
	   this:

	     my $dt = DateTime-&gtnow( time_zone =&gt 'local' )-&gtset_time_zone('floating');

       o   use UTC for all calculations

	   If you do care about time zones (particularly DST) or leap seconds,
	   try to use non-UTC time zones for presentation and user input only.
	   Convert to UTC immediately and convert back to the local time zone
	   for presentation:

	     my $dt = DateTime-&gtnew( %user_input, time_zone =&gt $user_tz );
	     $dt-&gtset_time_zone('UTC');

	     # do various operations - store it, retrieve it, add, subtract, etc.

	     $dt-&gtset_time_zone($user_tz);
	     print $dt-&gtdatetime;

       o   math on non-UTC time zones

	   If you need to do date math on objects with non-UTC time zones,
	   please read the caveats below carefully. The results "DateTime.pm"
	   produces are predictable and correct, and mostly intuitive, but
	   datetime math gets very ugly when time zones are involved, and
	   there are a few strange corner cases involving subtraction of two
	   datetimes across a DST change.

	   If you can always use the floating or UTC time zones, you can skip
	   ahead to Leap Seconds and Date Math

       o   date vs datetime math

	   If you only care about the date (calendar) portion of a datetime,
	   you should use either "delta_md()" or "delta_days()", not
	   "subtract_datetime()". This will give predictable, unsurprising
	   results, free from DST-related complications.

       o   subtract_datetime() and add_duration()

	   You must convert your datetime objects to the UTC time zone before
	   doing date math if you want to make sure that the following
	   formulas are always true:

	     $dt2 - $dt1 = $dur
	     $dt1 + $dur = $dt2
	     $dt2 - $dur = $dt1

	   Note that using "delta_days" ensures that this formula always
	   works, regardless of the timezone of the objects involved, as does
	   using "subtract_datetime_absolute()". Other methods of subtraction
	   are not always reversible.

       Adding a Duration to a Datetime

       The parts of a duration can be broken down into five parts. These are
       months, days, minutes, seconds, and nanoseconds. Adding one month to a
       date is different than adding 4 weeks or 28, 29, 30, or 31 days.
       Similarly, due to DST and leap seconds, adding a day can be different
       than adding 86,400 seconds, and adding a minute is not exactly the same
       as 60 seconds.

       We cannot convert between these units, except for seconds and
       nanoseconds, because there is no fixed conversion between the two
       units, because of things like leap seconds, DST changes, etc.

       "DateTime.pm" always adds (or subtracts) days, then months, minutes,
       and then seconds and nanoseconds. If there are any boundary overflows,
       these are normalized at each step. For the days and months the local
       (not UTC) values are used. For minutes and seconds, the local values
       are used. This generally just works.

       This means that adding one month and one day to February 28, 2003 will
       produce the date April 1, 2003, not March 29, 2003.

	 my $dt = DateTime-&gtnew( year =&gt 2003, month =&gt 2, day =&gt 28 );

	 $dt-&gtadd( months =&gt 1, days =&gt 1 );

	 # 2003-04-01 - the result

       On the other hand, if we add months first, and then separately add
       days, we end up with March 29, 2003:

	 $dt-&gtadd( months =&gt 1 )-&gtadd( days =&gt 1 );

	 # 2003-03-29

       We see similar strangeness when math crosses a DST boundary:

	 my $dt = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 5,
	     hour      =&gt 1,
	     minute    =&gt 58,
	     time_zone =&gt "America/Chicago",
	 );

	 $dt-&gtadd( days =&gt 1, minutes =&gt 3 );
	 # 2003-04-06 02:01:00

	 $dt-&gtadd( minutes =&gt 3 )-&gtadd( days =&gt 1 );
	 # 2003-04-06 03:01:00

       Note that if you converted the datetime object to UTC first you would
       get predictable results.

       If you want to know how many seconds a duration object represents, you
       have to add it to a datetime to find out, so you could do:

	my $now = DateTime-&gtnow( time_zone =&gt 'UTC' );
	my $later = $now-&gtclone-&gtadd_duration($duration);

	my $seconds_dur = $later-&gtsubtract_datetime_absolute($now);

       This returns a duration which only contains seconds and nanoseconds.

       If we were add the duration to a different datetime object we might get
       a different number of seconds.

       DateTime::Duration supports three different end-of-month algorithms for
       adding months. This comes into play when an addition results in a day
       past the end of the month (for example, adding one month to January
       30).

	# 2010-08-31 + 1 month = 2010-10-01
	$dt-&gtadd( months =&gt 1, end_of_month =&gt 'wrap' );

	# 2010-01-30 + 1 month = 2010-02-28
	$dt-&gtadd( months =&gt 1, end_of_month =&gt 'limit' );

	# 2010-04-30 + 1 month = 2010-05-31
	$dt-&gtadd( months =&gt 1, end_of_month =&gt 'preserve' );

       By default, it uses "wrap" for positive durations and "preserve" for
       negative durations. See DateTime::Duration for a detailed explanation
       of these algorithms.

       If you need to do lots of work with durations, take a look at Rick
       Measham's "DateTime::Format::Duration" module, which lets you present
       information from durations in many useful ways.

       There are other subtract/delta methods in DateTime.pm to generate
       different types of durations. These methods are "subtract_datetime()",
       "subtract_datetime_absolute()", "delta_md()", "delta_days()", and
       "delta_ms()".

       Datetime Subtraction

       Date subtraction is done solely based on the two object's local
       datetimes, with one exception to handle DST changes. Also, if the two
       datetime objects are in different time zones, one of them is converted
       to the other's time zone first before subtraction. This is best
       explained through examples:

       The first of these probably makes the most sense:

	 my $dt1 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 5,
	     day       =&gt 6,
	     time_zone =&gt 'America/Chicago',
	 );

	 # not DST

	 my $dt2 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 11,
	     day       =&gt 6,
	     time_zone =&gt 'America/Chicago',
	 );

	 # is DST

	 my $dur = $dt2-&gtsubtract_datetime($dt1);
	 # 6 months

       Nice and simple.

       This one is a little trickier, but still fairly logical:

	 my $dt1 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 5,
	     hour      =&gt 1,
	     minute    =&gt 58,
	     time_zone =&gt "America/Chicago",
	 );

	 # is DST

	 my $dt2 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 7,
	     hour      =&gt 2,
	     minute    =&gt 1,
	     time_zone =&gt "America/Chicago",
	 );

	 # not DST

	 my $dur = $dt2-&gtsubtract_datetime($dt1);

	 # 2 days and 3 minutes

       Which contradicts the result this one gives, even though they both make
       sense:

	 my $dt1 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 5,
	     hour      =&gt 1,
	     minute    =&gt 58,
	     time_zone =&gt "America/Chicago",
	 );

	 # is DST

	 my $dt2 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 6,
	     hour      =&gt 3,
	     minute    =&gt 1,
	     time_zone =&gt "America/Chicago",
	 );

	 # not DST

	 my $dur = $dt2-&gtsubtract_datetime($dt1);

	 # 1 day and 3 minutes

       This last example illustrates the "DST" exception mentioned earlier.
       The exception accounts for the fact 2003-04-06 only lasts 23 hours.

       And finally:

	 my $dt2 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 10,
	     day       =&gt 26,
	     hour      =&gt 1,
	     time_zone =&gt 'America/Chicago',
	 );

	 my $dt1 = $dt2-&gtclone-&gtsubtract( hours =&gt 1 );

	 my $dur = $dt2-&gtsubtract_datetime($dt1);
	 # 60 minutes

       This seems obvious until you realize that subtracting 60 minutes from
       $dt2 in the above example still leaves the clock time at "01:00:00".
       This time we are accounting for a 25 hour day.

       Reversibility

       Date math operations are not always reversible. This is because of the
       way that addition operations are ordered. As was discussed earlier,
       adding 1 day and 3 minutes in one call to "add()" is not the same as
       first adding 3 minutes and 1 day in two separate calls.

       If we take a duration returned from "subtract_datetime()" and then try
       to add or subtract that duration from one of the datetimes we just
       used, we sometimes get interesting results:

	 my $dt1 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 5,
	     hour      =&gt 1,
	     minute    =&gt 58,
	     time_zone =&gt "America/Chicago",
	 );

	 my $dt2 = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 6,
	     hour      =&gt 3,
	     minute    =&gt 1,
	     time_zone =&gt "America/Chicago",
	 );

	 my $dur = $dt2-&gtsubtract_datetime($dt1);
	 # 1 day and 3 minutes

	 $dt1-&gtadd_duration($dur);
	 # gives us $dt2

	 $dt2-&gtsubtract_duration($dur);
	 # gives us 2003-04-05 02:58:00 - 1 hour later than $dt1

       The "subtract_dauration()" operation gives us a (perhaps) unexpected
       answer because it first subtracts one day to get 2003-04-05T03:01:00
       and then subtracts 3 minutes to get the final result.

       If we explicitly reverse the order we can get the original value of
       $dt1. This can be facilitated by "DateTime::Duration"'s
       "calendar_duration()" and "clock_duration()" methods:

	 $dt2-&gtsubtract_duration( $dur-&gtclock_duration )
	     -&gtsubtract_duration( $dur-&gtcalendar_duration );

       Leap Seconds and Date Math

       The presence of leap seconds can cause even more anomalies in date
       math. For example, the following is a legal datetime:

	 my $dt = DateTime-&gtnew(
	     year      =&gt 1972,
	     month     =&gt 12,
	     day       =&gt 31,
	     hour      =&gt 23,
	     minute    =&gt 59,
	     second    =&gt 60,
	     time_zone =&gt 'UTC'
	 );

       If we do the following:

	$dt-&gtadd( months =&gt 1 );

       Then the datetime is now "1973-02-01 00:00:00", because there is no
       23:59:60 on 1973-01-31.

       Leap seconds also force us to distinguish between minutes and seconds
       during date math. Given the following datetime:

	 my $dt = DateTime-&gtnew(
	     year      =&gt 1972,
	     month     =&gt 12,
	     day       =&gt 31,
	     hour      =&gt 23,
	     minute    =&gt 59,
	     second    =&gt 30,
	     time_zone =&gt 'UTC'
	 );

       we will get different results when adding 1 minute than we get if we
       add 60 seconds. This is because in this case, the last minute of the
       day, beginning at 23:59:00, actually contains 61 seconds.

       Here are the results we get:

	 # 1972-12-31 23:59:30 - our starting datetime

	 $dt-&gtclone-&gtadd( minutes =&gt 1 );
	 # 1973-01-01 00:00:30 - one minute later

	 $dt-&gtclone-&gtadd( seconds =&gt 60 );
	 # 1973-01-01 00:00:29 - 60 seconds later

	 $dt-&gtclone-&gtadd( seconds =&gt 61 );
	 # 1973-01-01 00:00:30 - 61 seconds later

       Local vs. UTC and 24 hours vs. 1 day

       When math crosses a daylight saving boundary, a single day may have
       more or less than 24 hours.

       For example, if you do this:

	 my $dt = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 5,
	     hour      =&gt 2,
	     time_zone =&gt 'America/Chicago',
	 );

	 $dt-&gtadd( days =&gt 1 );

       then you will produce an invalid local time, and therefore an exception
       will be thrown.

       However, this works:

	 my $dt = DateTime-&gtnew(
	     year      =&gt 2003,
	     month     =&gt 4,
	     day       =&gt 5,
	     hour      =&gt 2,
	     time_zone =&gt 'America/Chicago',
	 );

	 $dt-&gtadd( hours =&gt 24 );

       and produces a datetime with the local time of "03:00".

       If all this makes your head hurt, there is a simple alternative. Just
       convert your datetime object to the "UTC" time zone before doing date
       math on it, and switch it back to the local time zone afterwards.  This
       avoids the possibility of having date math throw an exception, and
       makes sure that 1 day equals 24 hours. Of course, this may not always
       be desirable, so caveat user!

   Overloading
       This module explicitly overloads the addition (+), subtraction (-),
       string and numeric comparison operators. This means that the following
       all do sensible things:

	 my $new_dt = $dt + $duration_obj;

	 my $new_dt = $dt - $duration_obj;

	 my $duration_obj = $dt - $new_dt;

	 foreach my $dt ( sort @dts ) { ... }

       Additionally, the fallback parameter is set to true, so other derivable
       operators (+=, -=, etc.) will work properly. Do not expect increment
       (++) or decrement (--) to do anything useful.

       The string comparison operators, "eq" or "ne", will use the string
       value to compare with non-DateTime objects.

       DateTime objects do not have a numeric value, using "==" or "&lt=&gt" to
       compare a DateTime object with a non-DateTime object will result in an
       exception. To safely sort mixed DateTime and non-DateTime objects, use
       "sort { $a cmp $b } @dates".

       The module also overloads stringification using the object's formatter,
       defaulting to "iso8601()" method. See "Formatters And Stringification"
       for details.

   Formatters And Stringification
       You can optionally specify a "formatter", which is usually a
       DateTime::Format::* object/class, to control the stringification of the
       DateTime object.

       Any of the constructor methods can accept a formatter argument:

	 my $formatter = DateTime::Format::Strptime-&gtnew(...);
	 my $dt = DateTime-&gtnew(year =&gt 2004, formatter =&gt $formatter);

       Or, you can set it afterwards:

	 $dt-&gtset_formatter($formatter);
	 $formatter = $dt-&gtformatter();

       Once you set the formatter, the overloaded stringification method will
       use the formatter. If unspecified, the "iso8601()" method is used.

       A formatter can be handy when you know that in your application you
       want to stringify your DateTime objects into a special format all the
       time, for example to a different language.

       If you provide a formatter class name or object, it must implement a
       "format_datetime" method. This method will be called with just the
       DateTime object as its argument.

   CLDR Patterns
       The CLDR pattern language is both more powerful and more complex than
       strftime. Unlike strftime patterns, you often have to explicitly escape
       text that you do not want formatted, as the patterns are simply letters
       without any prefix.

       For example, "yyyy-MM-dd" is a valid CLDR pattern. If you want to
       include any lower or upper case ASCII characters as-is, you can
       surround them with single quotes ('). If you want to include a single
       quote, you must escape it as two single quotes ('').

	 'Today is ' EEEE
	 'It is now' h 'o''clock' a

       Spaces and any non-letter text will always be passed through as-is.

       Many CLDR patterns which produce numbers will pad the number with
       leading zeroes depending on the length of the format specifier. For
       example, "h" represents the current hour from 1-12. If you specify "hh"
       then the 1-9 will have a leading zero prepended.

       However, CLDR often uses five of a letter to represent the narrow form
       of a pattern. This inconsistency is necessary for backwards
       compatibility.

       CLDR often distinguishes between the "format" and "stand-alone" forms
       of a pattern. The format pattern is used when the thing in question is
       being placed into a larger string. The stand-alone form is used when
       displaying that item by itself, for example in a calendar.

       It also often provides three sizes for each item, wide (the full name),
       abbreviated, and narrow. The narrow form is often just a single
       character, for example "T" for "Tuesday", and may not be unique.

       CLDR provides a fairly complex system for localizing time zones that we
       ignore entirely. The time zone patterns just use the information
       provided by "DateTime::TimeZone", and do not follow the CLDR spec.

       The output of a CLDR pattern is always localized, when applicable.

       CLDR provides the following patterns:

       o   G{1,3}

	   The abbreviated era (BC, AD).

       o   GGGG

	   The wide era (Before Christ, Anno Domini).

       o   GGGGG

	   The narrow era, if it exists (and it mostly doesn't).

       o   y and y{3,}

	   The year, zero-prefixed as needed. Negative years will start with a
	   "-", and this will be included in the length calculation.

	   In other, words the "yyyyy" pattern will format year -1234 as
	   "-1234", not "-01234".

       o   yy

	   This is a special case. It always produces a two-digit year, so
	   "1976" becomes "76". Negative years will start with a "-", making
	   them one character longer.

       o   Y{1,}

	   The week of the year, from "$dt-&gtweek_year()".

       o   u{1,}

	   Same as "y" except that "uu" is not a special case.

       o   Q{1,2}

	   The quarter as a number (1..4).

       o   QQQ

	   The abbreviated format form for the quarter.

       o   QQQQ

	   The wide format form for the quarter.

       o   q{1,2}

	   The quarter as a number (1..4).

       o   qqq

	   The abbreviated stand-alone form for the quarter.

       o   qqqq

	   The wide stand-alone form for the quarter.

       o   M{1,2]

	   The numerical month.

       o   MMM

	   The abbreviated format form for the month.

       o   MMMM

	   The wide format form for the month.

       o   MMMMM

	   The narrow format form for the month.

       o   L{1,2]

	   The numerical month.

       o   LLL

	   The abbreviated stand-alone form for the month.

       o   LLLL

	   The wide stand-alone form for the month.

       o   LLLLL

	   The narrow stand-alone form for the month.

       o   w{1,2}

	   The week of the year, from "$dt-&gtweek_number()".

       o   W

	   The week of the month, from "$dt-&gtweek_of_month()".

       o   d{1,2}

	   The numeric day of of the month.

       o   D{1,3}

	   The numeric day of of the year.

       o   F

	   The day of the week in the month, from "$dt-&gtweekday_of_month()".

       o   g{1,}

	   The modified Julian day, from "$dt-&gtmjd()".

       o   E{1,3} and eee

	   The abbreviated format form for the day of the week.

       o   EEEE and eeee

	   The wide format form for the day of the week.

       o   EEEEE and eeeee

	   The narrow format form for the day of the week.

       o   e{1,2}

	   The local numeric day of the week, from 1 to 7. This number depends
	   on what day is considered the first day of the week, which varies
	   by locale. For example, in the US, Sunday is the first day of the
	   week, so this returns 2 for Monday.

       o   c

	   The numeric day of the week from 1 to 7, treating Monday as the
	   first of the week, regardless of locale.

       o   ccc

	   The abbreviated stand-alone form for the day of the week.

       o   cccc

	   The wide stand-alone form for the day of the week.

       o   ccccc

	   The narrow format form for the day of the week.

       o   a

	   The localized form of AM or PM for the time.

       o   h{1,2}

	   The hour from 1-12.

       o   H{1,2}

	   The hour from 0-23.

       o   K{1,2}

	   The hour from 0-11.

       o   k{1,2}

	   The hour from 1-24.

       o   j{1,2}

	   The hour, in 12 or 24 hour form, based on the preferred form for
	   the locale. In other words, this is equivalent to either "h{1,2}"
	   or "H{1,2}".

       o   m{1,2}

	   The minute.

       o   s{1,2}

	   The second.

       o   S{1,}

	   The fractional portion of the seconds, rounded based on the length
	   of the specifier. This returned without a leading decimal point,
	   but may have leading or trailing zeroes.

       o   A{1,}

	   The millisecond of the day, based on the current time. In other
	   words, if it is 12:00:00.00, this returns 43200000.

       o   z{1,3}

	   The time zone short name.

       o   zzzz

	   The time zone long name.

       o   Z{1,3}

	   The time zone offset.

       o   ZZZZ

	   The time zone short name and the offset as one string, so something
	   like "CDT-0500".

       o   v{1,3}

	   The time zone short name.

       o   vvvv

	   The time zone long name.

       o   V{1,3}

	   The time zone short name.

       o   VVVV

	   The time zone long name.

   strftime Patterns
       The following patterns are allowed in the format string given to the
       "$dt-&gtstrftime()" method:

       o   %a

	   The abbreviated weekday name.

       o   %A

	   The full weekday name.

       o   %b

	   The abbreviated month name.

       o   %B

	   The full month name.

       o   %c

	   The default datetime format for the object's locale.

       o   %C

	   The century number (year/100) as a 2-digit integer.

       o   %d

	   The day of the month as a decimal number (range 01 to 31).

       o   %D

	   Equivalent to %m/%d/%y. This is not a good standard format if you
	   want folks from both the United States and the rest of the world to
	   understand the date!

       o   %e

	   Like %d, the day of the month as a decimal number, but a leading
	   zero is replaced by a space.

       o   %F

	   Equivalent to %Y-%m-%d (the ISO 8601 date format)

       o   %G

	   The ISO 8601 year with century as a decimal number. The 4-digit
	   year corresponding to the ISO week number (see %V). This has the
	   same format and value as %Y, except that if the ISO week number
	   belongs to the previous or next year, that year is used instead.
	   (TZ)

       o   %g

	   Like %G, but without century, i.e., with a 2-digit year (00-99).

       o   %h

	   Equivalent to %b.

       o   %H

	   The hour as a decimal number using a 24-hour clock (range 00 to
	   23).

       o   %I

	   The hour as a decimal number using a 12-hour clock (range 01 to
	   12).

       o   %j

	   The day of the year as a decimal number (range 001 to 366).

       o   %k

	   The hour (24-hour clock) as a decimal number (range 0 to 23);
	   single digits are preceded by a blank. (See also %H.)

       o   %l

	   The hour (12-hour clock) as a decimal number (range 1 to 12);
	   single digits are preceded by a blank. (See also %I.)

       o   %m

	   The month as a decimal number (range 01 to 12).

       o   %M

	   The minute as a decimal number (range 00 to 59).

       o   %n

	   A newline character.

       o   %N

	   The fractional seconds digits. Default is 9 digits (nanoseconds).

	     %3N   milliseconds (3 digits)
	     %6N   microseconds (6 digits)
	     %9N   nanoseconds	(9 digits)

       o   %p

	   Either `AM' or `PM' according to the given time value, or the
	   corresponding strings for the current locale. Noon is treated as
	   `pm' and midnight as `am'.

       o   %P

	   Like %p but in lowercase: `am' or `pm' or a corresponding string
	   for the current locale.

       o   %r

	   The time in a.m. or p.m. notation. In the POSIX locale this is
	   equivalent to `%I:%M:%S %p'.

       o   %R

	   The time in 24-hour notation (%H:%M). (SU) For a version including
	   the seconds, see %T below.

       o   %s

	   The number of seconds since the epoch.

       o   %S

	   The second as a decimal number (range 00 to 61).

       o   %t

	   A tab character.

       o   %T

	   The time in 24-hour notation (%H:%M:%S).

       o   %u

	   The day of the week as a decimal, range 1 to 7, Monday being 1. See
	   also %w.

       o   %U

	   The week number of the current year as a decimal number, range 00
	   to 53, starting with the first Sunday as the first day of week 01.
	   See also %V and %W.

       o   %V

	   The ISO 8601:1988 week number of the current year as a decimal
	   number, range 01 to 53, where week 1 is the first week that has at
	   least 4 days in the current year, and with Monday as the first day
	   of the week. See also %U and %W.

       o   %w

	   The day of the week as a decimal, range 0 to 6, Sunday being 0. See
	   also %u.

       o   %W

	   The week number of the current year as a decimal number, range 00
	   to 53, starting with the first Monday as the first day of week 01.

       o   %x

	   The default date format for the object's locale.

       o   %X

	   The default time format for the object's locale.

       o   %y

	   The year as a decimal number without a century (range 00 to 99).

       o   %Y

	   The year as a decimal number including the century.

       o   %z

	   The time-zone as hour offset from UTC. Required to emit
	   RFC822-conformant dates (using "%a, %d %b %Y %H:%M:%S %z").

       o   %Z

	   The time zone or name or abbreviation.

       o   %%

	   A literal `%' character.

       o   %{method}

	   Any method name may be specified using the format "%{method}" name
	   where "method" is a valid "DateTime.pm" object method.

   DateTime.pm and Storable
       DateTime implements Storable hooks in order to reduce the size of a
       serialized DateTime object.

THE DATETIME PROJECT ECOSYSTEM
       This module is part of a larger ecosystem of modules in the DateTime
       family.

   DateTime::Set
       The DateTime::Set module represents sets (including recurrences) of
       datetimes. Many modules return sets or recurrences.

   Format Modules
       The various format modules exist to parse and format datetimes. For
       example, DateTime::Format::HTTP parses dates according to the RFC 1123
       format:

	 my $datetime
	     = DateTime::Format::HTTP-&gtparse_datetime('Thu Feb	3 17:03:55 GMT 1994');

	 print DateTime::Format::HTTP-&gtformat_datetime($datetime);

       Most format modules are suitable for use as a "formatter" with a
       DateTime object.

       All format modules start with "DateTime::Format::".

   Calendar Modules
       There are a number of modules on CPAN that implement non-Gregorian
       calendars, such as the Chinese, Mayan, and Julian calendars.

       All calendar modules start with "DateTime::Calendar::".

   Event Modules
       There are a number of modules that calculate the dates for events, such
       as Easter, Sunrise, etc.

       All event modules start with "DateTime::Event::".

   Others
       There are many other modules that work with DateTime, including modules
       in the "DateTimeX" namespace, as well as others.

       See the datetime wiki &lthttp://datetime.perl.org&gt and search.cpan.org
       &lthttp://search.cpan.org/search?query=datetime&mode=dist&gt for more
       details.

KNOWN BUGS
       The tests in 20infinite.t seem to fail on some machines, particularly
       on Win32. This appears to be related to Perl's internal handling of
       IEEE infinity and NaN, and seems to be highly platform/compiler/phase
       of moon dependent.

       If you don't plan to use infinite datetimes you can probably ignore
       this. This will be fixed (perhaps) in future versions.

SUPPORT
       Support for this module is provided via the datetime@perl.org email
       list. See http://datetime.perl.org/wiki/datetime/page/Mailing_List for
       details.

       Please submit bugs to the CPAN RT system at
       http://rt.cpan.org/NoAuth/Bugs.html?Dist=DateTime or via email at
       bug-datetime@rt.cpan.org.

DONATIONS
       If you'd like to thank me for the work I've done on this module, please
       consider making a "donation" to me via PayPal. I spend a lot of free
       time creating free software, and would appreciate any support you'd
       care to offer.

       Please note that I am not suggesting that you must do this in order for
       me to continue working on this particular software. I will continue to
       do so, inasmuch as I have in the past, for as long as it interests me.

       Similarly, a donation made in this way will probably not make me work
       on this software much more, unless I get so many donations that I can
       consider working on free software full time, which seems unlikely at
       best.

       To donate, log into PayPal and send money to autarch@urth.org or use
       the button on this page: http://www.urth.org/~autarch/fs-donation.html
       &lthttp://www.urth.org/~autarch/fs-donation.html&gt

SEE ALSO
       datetime@perl.org mailing list

       http://datetime.perl.org/

AUTHOR
       Dave Rolsky &ltautarch@urth.org&gt

COPYRIGHT AND LICENSE
       This software is Copyright (c) 2011 by Dave Rolsky.

       This is free software, licensed under:

	 The Artistic License 2.0 (GPL Compatible)



perl v5.12.4			  2012-06-20			   DateTime(3)
    </pre></body>

</html>
