<!DOCTYPE html>
<html>
    <head>
        <meta name="description" content="The is the PPI Lexer. In the larger scheme of things, its job is to..." />
        <meta http-equiv="Content-Type" CONTENT="text/html; charset="utf-8" />
        <title>PPI::Lexer - The PPI Lexer</title>
        <META NAME="robots" CONTENT="all" />
    </head>
    
<body><pre>
PPI::Lexer(3)	      User Contributed Perl Documentation	 PPI::Lexer(3)



NAME
       PPI::Lexer - The PPI Lexer

SYNOPSIS
	 use PPI;

	 # Create a new Lexer
	 my $Lexer = PPI::Lexer->new;

	 # Build a PPI::Document object from a Token stream
	 my $Tokenizer = PPI::Tokenizer->load('My/Module.pm');
	 my $Document = $Lexer->lex_tokenizer($Tokenizer);

	 # Build a PPI::Document object for some raw source
	 my $source = "print 'Hello World!'; kill(Humans->all);";
	 $Document = $Lexer->lex_source($source);

	 # Build a PPI::Document object for a particular file name
	 $Document = $Lexer->lex_file('My/Module.pm');

DESCRIPTION
       The is the PPI Lexer. In the larger scheme of things, its job is to
       take token streams, in a variety of forms, and "lex" them into nested
       structures.

       Pretty much everything in this module happens behind the scenes at this
       point. In fact, at the moment you don't really need to instantiate the
       lexer at all, the three main methods will auto-instantiate themselves a
       "PPI::Lexer" object as needed.

       All methods do a one-shot "lex this and give me a PPI::Document
       object".

       In fact, if you are reading this, what you probably want to do is to
       just "load a document", in which case you can do this in a much more
       direct and concise manner with one of the following.

	 use PPI;

	 $Document = PPI::Document->load( $filename );
	 $Document = PPI::Document->new( $string );

       See PPI::Document for more details.

       For more unusual tasks, by all means forge onwards.

METHODS
   new
       The "new" constructor creates a new "PPI::Lexer" object. The object
       itself is merely used to hold various buffers and state data during the
       lexing process, and holds no significant data between ->lex_xxxxx
       calls.

       Returns a new "PPI::Lexer" object

   lex_file $filename
       The "lex_file" method takes a filename as argument. It then loads the
       file, creates a PPI::Tokenizer for the content and lexes the token
       stream produced by the tokenizer. Basically, a sort of all-in-one
       method for getting a PPI::Document object from a file name.

       Returns a PPI::Document object, or "undef" on error.

   lex_source $string
       The "lex_source" method takes a normal scalar string as argument. It
       creates a PPI::Tokenizer object for the string, and then lexes the
       resulting token stream.

       Returns a PPI::Document object, or "undef" on error.

   lex_tokenizer $Tokenizer
       The "lex_tokenizer" takes as argument a PPI::Tokenizer object. It lexes
       the token stream from the tokenizer into a PPI::Document object.

       Returns a PPI::Document object, or "undef" on error.

   errstr
       For any error that occurs, you can use the "errstr", as either a static
       or object method, to access the error message.

       If no error occurs for any particular action, "errstr" will return
       false.

TO DO
       - Add optional support for some of the more common source filters

       - Some additional checks for blessing things into various Statement and
       Structure subclasses.

SUPPORT
       See the support section in the main module.

AUTHOR
       Adam Kennedy <adamk@cpan.org>

COPYRIGHT
       Copyright 2001 - 2011 Adam Kennedy.

       This program is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

       The full text of the license can be found in the LICENSE file included
       with this module.



perl v5.12.4			  2011-02-25			 PPI::Lexer(3)
    </pre><script type="text/javascript" src="../js/ga.js"></script></body>

</html>
